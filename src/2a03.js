// Generated by CoffeeScript 1.9.3
(function() {
  var CPU;

  CPU = (function() {
    CPU.prototype.RAM_SIZE = 0xFFFF;

    CPU.prototype.SP_INIT_VAL = 0xFD;

    CPU.prototype.PC_INIT_VAL = 0xFFFC;

    CPU.prototype.BASE_STACK_ADDR = 0x100;

    CPU.prototype.VECTOR_TABLE = {
      NMI: 0xFFFA,
      RST: 0xFFFC,
      IRQ: 0xFFFE
    };

    CPU.prototype.READ_LENGTH = {
      L: 8,
      HL: 16
    };

    CPU.prototype.ADDRESSING_MODE = {
      ACCUMULATOR: 'ACC',
      IMMEDIATE: 'IMM',
      IMPLIED: 'IMP'
    };

    function CPU(ram) {
      var i, ref, x;
      this.ram = ram != null ? ram : [];
      for (x = i = 0, ref = CPU.prototype.RAM_SIZE; 0 <= ref ? i <= ref : i >= ref; x = 0 <= ref ? ++i : --i) {
        this.ram[x] = 0;
      }
      this.PC = CPU.prototype.PC_INIT_VAL;
      this.AC = 0;
      this.XR = 0;
      this.YR = 0;
      this.SR = 0;
      this.SP = CPU.prototype.SP_INIT_VAL;
      this.N = 0;
      this.V = 0;
      this.U = 1;
      this.B = 0;
      this.D = 0;
      this.I = 0;
      this.Z = 0;
      this.C = 0;
      this.cycles = 0;
    }

    CPU.prototype.RST = function() {
      this.PC = this.PC_INIT_VAL;
      this.SP = this.SP_INIT_VAL;
      return this.cycles = 0;
    };

    CPU.prototype.clear = function() {
      var i, ref, results, x;
      results = [];
      for (x = i = 0, ref = CPU.prototype.RAM_SIZE; 0 <= ref ? i <= ref : i >= ref; x = 0 <= ref ? ++i : --i) {
        results.push(this.ram[x] = 0);
      }
      return results;
    };

    CPU.prototype.read = function(address, readingLength) {
      var h, l;
      if (readingLength === CPU.prototype.READ_LENGTH.HL) {
        l = this.ram[address];
        h = this.ram[address + 1];
        return h << 8 | l;
      } else {
        return this.ram[address];
      }
    };


    /*
      Stack operations
     */

    CPU.prototype.push = function(value) {
      if (value > 0xFF) {
        this.push(value >> 8);
        return this.push(value & 0xFF);
      } else {
        this.ram[CPU.prototype.BASE_STACK_ADDR + this.SP] = value;
        this.SP--;
        return this.SP &= 0xFF;
      }
    };

    CPU.prototype.pop = function() {
      this.SP++;
      this.SP &= 0xFF;
      return this.ram[CPU.prototype.BASE_STACK_ADDR + this.SP];
    };

    CPU.prototype.getP = function() {
      return this.N << 7 | this.V << 6 | this.U << 5 | this.B << 4 | this.D << 3 | this.I << 2 | this.Z << 1 | this.C;
    };

    CPU.prototype.setP = function(P) {
      this.N = P >> 7 & 0x1;
      this.V = P >> 6 & 0x1;
      this.U = P >> 5 & 0x1;
      this.B = P >> 4 & 0x1;
      this.D = P >> 3 & 0x1;
      this.I = P >> 2 & 0x1;
      this.Z = P >> 1 & 0x1;
      return this.C = P & 0x1;
    };


    /*
     Interruption
     */

    CPU.prototype.NMI = function() {
      this.push(this.PC);
      return this.PC = pop();
    };

    CPU.prototype.IRQ = function() {};

    CPU.prototype.printRegisters = function() {
      return console.log('AC=', this.AC, '(= BDC', this.AC.toString(16), ') V=', this.V, 'C=', this.C, 'N=', this.N, 'Z=', this.Z);
    };

    CPU.prototype.accumulator = function() {
      return {
        operand: this.AC,
        address: CPU.prototype.ADDRESSING_MODE.ACCUMULATOR
      };
    };

    CPU.prototype.absolute = function(oper) {
      return {
        operand: this.ram[oper],
        address: oper
      };
    };

    CPU.prototype.absoluteX = function(oper) {
      return {
        operand: this.ram[oper + this.XR],
        address: oper + this.XR
      };
    };

    CPU.prototype.absoluteY = function(oper) {
      return {
        operand: this.ram[oper + this.YR],
        address: oper + this.YR
      };
    };

    CPU.prototype.immediate = function(oper) {
      return {
        operand: oper,
        address: CPU.prototype.ADDRESSING_MODE.IMMEDIATE
      };
    };

    CPU.prototype.implied = function(oper) {
      return {
        operand: this.AC,
        address: CPU.prototype.ADDRESSING_MODE.IMPLIED
      };
    };

    CPU.prototype.indirect = function(oper) {
      return {
        operand: this.ram[this.ram[oper]],
        address: this.ram[oper]
      };
    };

    CPU.prototype.indirectX = function(oper) {
      return {
        operand: this.ram[this.ram[(oper & 0x00FF) + this.XR]],
        address: this.ram[(oper & 0x00FF) + this.XR]
      };
    };

    CPU.prototype.indirectY = function(oper) {
      return {
        operand: this.ram[this.ram[(oper & 0x00FF) + this.YR]],
        address: this.ram[(oper & 0x00FF) + this.YR]
      };
    };

    CPU.prototype.relative = function(oper) {
      return {
        operand: this.ram[this.PC + oper],
        address: this.PC + oper
      };
    };

    CPU.prototype.zeropage = function(oper) {
      return {
        operand: this.ram[oper & 0x00FF],
        address: oper & 0x00FF
      };
    };

    CPU.prototype.zeropageX = function(oper) {
      return {
        operand: this.ram[(oper + this.XR) & 0x00FF],
        address: oper + this.XR
      };
    };

    CPU.prototype.zeropageY = function(oper) {
      return {
        operand: this.ram[(oper + this.YR) & 0x00FF],
        address: oper + this.YR
      };
    };

    CPU.prototype.addressing = function() {
      if (arguments.length === 2) {
        return arguments[1];
      } else {
        return this.immediate;
      }
    };

    CPU.stepInfo = {
      operand: 0x00,
      addressMode: null
    };

    CPU.prototype.step = function() {
      var operand;
      operand = this.ram[this.PC];
      this.stepInfo.operand = operand;
      return this.stepInfo.addressMode = this.immediate(operand);
    };

    CPU.prototype.accumulate = function(src, dst, carry) {
      return src + dst + carry;
    };

    CPU.prototype.setZ = function(oper) {
      return this.Z = oper === 0 ? 1 : 0;
    };

    CPU.prototype.setN = function(oper) {
      return this.N = (oper & 0x80) !== 0 ? 1 : 0;
    };

    CPU.prototype.setZN = function(oper) {
      this.setZ(oper);
      return this.setN(oper);
    };

    CPU.prototype.addCycleOnBranch = function(stepInfo) {
      return this.cycles += 1;
    };

    CPU.prototype.SED = function() {
      return this.D = 1;
    };

    CPU.prototype.SEC = function() {
      return this.C = 1;
    };

    CPU.prototype.CLC = function() {
      return this.C = 0;
    };

    CPU.prototype.CLD = function() {
      return this.D = 0;
    };

    CPU.prototype.LDA = function(oper) {
      return this.AC = this.addressing(arguments)(oper);
    };


    /*
    ADC  Add Memory to Accumulator with Carry
    
       A + M + C -> A, C                N Z C I D V
                                        + + + - - +
    
       addressing    assembler    opc  bytes  cyles
       --------------------------------------------
       immidiate     ADC #oper     69    2     2
       zeropage      ADC oper      65    2     3
       zeropage,X    ADC oper,X    75    2     4
       absolute      ADC oper      6D    3     4
       absolute,X    ADC oper,X    7D    3     4*
       absolute,Y    ADC oper,Y    79    3     4*
       (indirect,X)  ADC (oper,X)  61    2     6
       (indirect),Y  ADC (oper),Y  71    2     5*
     */

    CPU.prototype.ADC = function(stepInfo) {
      var H4b, operand;
      operand = stepInfo.operand;
      this.AC = this.accumulate(operand, this.AC, this.C);
      console.log('@AC', this.AC);
      this.C = this.AC > 0xFF ? 1 : 0;
      this.setZN(this.AC);
      H4b = this.AC / 0x10;
      this.V = H4b >= -8 & H4b <= 7 ? 0 : 1;
      if (this.V === 1) {
        console.warn('High 4 bit', H4b.toString(16), 'is not in rage(-8~7). Overflow!!');
      }
      console.log('@H4b is', H4b.toString(16));
      this.AC = this.AC & 0xFF;
      return this.printRegisters();
    };

    CPU.prototype.SBC = function(stepInfo) {
      var H4b, operand;
      operand = -stepInfo.operand;
      this.AC = this.accumulate(operand, this.AC, this.C);
      console.log('@AC', this.AC);
      this.C = this.AC > 0xFF ? 1 : 0;
      this.setZN(this.AC);
      H4b = this.AC / 0x10;
      this.V = H4b >= -8 & H4b <= 7 ? 0 : 1;
      if (this.V === 1) {
        console.warn('High 4 bit', H4b.toString(16), 'is not in rage(-8~7). Overflow!!');
      }
      console.log('@H4b is', H4b.toString(16));
      return this.AC = this.AC & 0xFF;
    };


    /*
    AND Memory with Accumulator
    
       A AND M -> A                     N Z C I D V
                                        + + - - - -
    
       addressing    assembler    opc  bytes  cyles
       --------------------------------------------
       immidiate     AND #oper     29    2     2
       zeropage      AND oper      25    2     3
       zeropage,X    AND oper,X    35    2     4
       absolute      AND oper      2D    3     4
       absolute,X    AND oper,X    3D    3     4*
       absolute,Y    AND oper,Y    39    3     4*
       (indirect,X)  AND (oper,X)  21    2     6
       (indirect),Y  AND (oper),Y  31    2     5*
     */

    CPU.prototype.AND = function(stepInfo) {
      var operand;
      operand = stepInfo.operand;
      this.AC = this.AC & operand & 0xFF;
      return this.setZN(this.AC);
    };


    /*
    ASL  Shift Left One Bit (Memory or Accumulator)
    
       C <- [76543210] <- 0             N Z C I D V
                                        + + + - - -
    
       addressing    assembler    opc  bytes  cyles
       --------------------------------------------
       accumulator   ASL A         0A    1     2
       zeropage      ASL oper      06    2     5
       zeropage,X    ASL oper,X    16    2     6
       absolute      ASL oper      0E    3     6
       absolute,X    ASL oper,X    1E    3     7
     */

    CPU.prototype.ASL = function(stepInfo) {
      var addressingMode, operand;
      operand = stepInfo.operand;
      addressingMode = stepInfo.addressMode;
      this.C = (operand >> 7) & 1;
      operand <<= 1;
      console.log(stepInfo, '1', addressingMode.address);
      if (addressingMode.address === CPU.prototype.ADDRESSING_MODE.ACCUMULATOR) {
        this.AC = operand;
      } else {
        this.ram[operand];
      }
      return this.setZN(operand);
    };


    /*
      BCC  Branch on Carry Clear
    
       branch on C = 0                  N Z C I D V
                                        - - - - - -
    
       addressing    assembler    opc  bytes  cyles
       --------------------------------------------
       relative      BCC oper      90    2     2**
     */

    CPU.prototype.BCC = function(stepInfo) {
      if (this.C === 0) {
        this.PC = stepInfo.addressMode.address;
        return this.addCycleOnBranch(stepInfo);
      }
    };


    /*
      BCS  Branch on Carry Set
    
       branch on C = 1                  N Z C I D V
                                        - - - - - -
    
       addressing    assembler    opc  bytes  cyles
       --------------------------------------------
       relative      BCS oper      B0    2     2**
     */

    CPU.prototype.BCS = function(stepInfo) {
      if (this.C === 1) {
        this.PC = stepInfo.addressMode.address;
        return this.addCycleOnBranch(stepInfo);
      }
    };


    /*
      BEQ  Branch on Result Zero
    
       branch on Z = 1                  N Z C I D V
                                        - - - - - -
    
       addressing    assembler    opc  bytes  cyles
       --------------------------------------------
       relative      BEQ oper      F0    2     2**
     */

    CPU.prototype.BEQ = function(stepInfo) {
      if (this.Z === 1) {
        this.PC = stepInfo.addressMode.address;
        return this.addCycleOnBranch(stepInfo);
      }
    };


    /*
      BIT  Test Bits in Memory with Accumulator
    
       bits 7 and 6 of operand are transfered to bit 7 and 6 of SR (N,V);
       the zeroflag is set to the result of operand AND accumulator.
    
       A AND M, M7 -> N, M6 -> V        N Z C I D V
                                       M7 + - - - M6
    
       addressing    assembler    opc  bytes  cycles
       --------------------------------------------
       zeropage      BIT oper      24    2     3
       absolute      BIT oper      2C    3     4
     */

    CPU.prototype.BIT = function(stepInfo) {
      console.log(stepInfo);
      this.N = stepInfo.operand >> 7 & 1;
      this.V = stepInfo.operand >> 6 & 1;
      return this.Z = stepInfo.operand & this.AC;
    };


    /*
      BMI  Branch on Result Minus
    
       branch on N = 1                  N Z C I D V
                                        - - - - - -
    
       addressing    assembler    opc  bytes  cycles
       --------------------------------------------
       relative      BMI oper      30    2     2**
     */

    CPU.prototype.BMI = function(stepInfo) {
      if (this.N === 1) {
        this.PC = stepInfo.addressMode.address;
        return this.addCycleOnBranch(stepInfo);
      }
    };


    /*
      BNE  Branch on Result not Zero
    
       branch on Z = 0                  N Z C I D V
                                        - - - - - -
    
       addressing    assembler    opc  bytes  cyles
       --------------------------------------------
       relative      BNE oper      D0    2     2**
     */

    CPU.prototype.BNE = function(stepInfo) {
      if (this.Z === 0) {
        this.PC = stepInfo.addressMode.address;
        return this.addCycleOnBranch(stepInfo);
      }
    };


    /*
      BPL  Branch on Result Plus
    
       branch on N = 0                  N Z C I D V
                                        - - - - - -
    
       addressing    assembler    opc  bytes  cyles
       --------------------------------------------
       relative      BPL oper      10    2     2**
     */

    CPU.prototype.BPL = function(stepInfo) {
      if (this.N === 0) {
        this.PC = stepInfo.addressMode.address;
        return this.addCycleOnBranch(stepInfo);
      }
    };


    /*
      BRK  Force Break
    
        interrupt,                       N Z C I D V
        push PC+2, push SR               - - - 1 - -
    
          addressing    assembler    opc  bytes  cyles
        --------------------------------------------
        implied       BRK           00    1     7
     */

    CPU.prototype.BRK = function(stepInfo) {
      this.I = 1;
      return this.PC += 2;
    };


    /*
      BVC  Branch on Overflow Clear
    
        branch on V = 0                  N Z C I D V
      - - - - - -
    
      addressing    assembler    opc  bytes  cyles
      --------------------------------------------
      relative      BVC oper      50    2     2**
     */


    /*
      BVS  Branch on Overflow Set
    
      branch on V = 1                  N Z C I D V
    - - - - - -
    
    addressing    assembler    opc  bytes  cyles
    --------------------------------------------
    relative      BVC oper      70    2     2**
     */


    /*
        CLC  Clear Carry Flag
    
          0 -> C                           N Z C I D V
      - - 0 - - -
    
      addressing    assembler    opc  bytes  cyles
      --------------------------------------------
      implied       CLC           18    1     2
     */

    exports.CPU = CPU;

    return CPU;

  })();

}).call(this);

//# sourceMappingURL=2a03.js.map
