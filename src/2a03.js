// Generated by CoffeeScript 1.9.3
(function() {
  var CPU;

  CPU = (function() {
    CPU.prototype.PC = 0;

    CPU.prototype.AC = 0;

    CPU.prototype.XR = 0;

    CPU.prototype.YR = 0;

    CPU.prototype.SR = 0;

    CPU.prototype.SP = 0;

    CPU.prototype.N = 0;

    CPU.prototype.V = 0;

    CPU.prototype.U = 1;

    CPU.prototype.B = 0;

    CPU.prototype.D = 0;

    CPU.prototype.I = 0;

    CPU.prototype.Z = 0;

    CPU.prototype.C = 0;

    CPU.prototype.ram = [];

    CPU.prototype.ramSize = 0xFFFF;

    function CPU() {
      var i, ref, x;
      for (x = i = 0, ref = this.ramSize; 0 <= ref ? i <= ref : i >= ref; x = 0 <= ref ? ++i : --i) {
        this.ram[x] = 0;
      }
    }

    CPU.prototype.reset = function() {
      return this.PC = 0;
    };

    CPU.prototype.clear = function() {
      var i, ref, results, x;
      results = [];
      for (x = i = 0, ref = this.ramSize; 0 <= ref ? i <= ref : i >= ref; x = 0 <= ref ? ++i : --i) {
        results.push(this.ram[x] = 0);
      }
      return results;
    };

    CPU.prototype.printRegisters = function() {
      return console.log('AC=', this.AC, '(= BDC', this.AC.toString(16), ') V=', this.V, 'C=', this.C, 'N=', this.N, 'Z=', this.Z);
    };

    CPU.prototype.ADDRESSING_MODE = {
      ACCUMULATOR: 'ACC',
      IMMEDIATE: 'IMM',
      IMPLIED: 'IMP'
    };

    CPU.prototype.accumulator = function() {
      return {
        operand: this.AC,
        address: this.ADDRESSING_MODE.ACCUMULATOR
      };
    };

    CPU.prototype.absolute = function(oper) {
      return {
        operand: this.ram[oper],
        address: oper
      };
    };

    CPU.prototype.absoluteX = function(oper) {
      return {
        operand: this.ram[oper + this.XR],
        address: oper + this.XR
      };
    };

    CPU.prototype.absoluteY = function(oper) {
      return {
        operand: this.ram[oper + this.YR],
        address: oper + this.YR
      };
    };

    CPU.prototype.immediate = function(oper) {
      return {
        operand: oper,
        address: this.ADDRESSING_MODE.IMMEDIATE
      };
    };

    CPU.prototype.implied = function(oper) {
      return {
        operand: this.AC,
        address: this.ADDRESSING_MODE.IMPLIED
      };
    };

    CPU.prototype.indirect = function(oper) {
      return {
        operand: this.ram[this.ram[oper]],
        address: this.ram[oper]
      };
    };

    CPU.prototype.indirectX = function(oper) {
      return {
        operand: this.ram[this.ram[(oper & 0x00FF) + this.XR]],
        address: this.ram[(oper & 0x00FF) + this.XR]
      };
    };

    CPU.prototype.indirectY = function(oper) {
      return {
        operand: this.ram[this.ram[(oper & 0x00FF) + this.YR]],
        address: this.ram[(oper & 0x00FF) + this.YR]
      };
    };

    CPU.prototype.relative = function(oper) {
      return {
        operand: this.ram[this.PC + oper],
        address: this.PC + oper
      };
    };

    CPU.prototype.zeropage = function(oper) {
      return {
        operand: this.ram[oper & 0x00FF],
        address: oper & 0x00FF
      };
    };

    CPU.prototype.zeropageX = function(oper) {
      return {
        operand: this.ram[(oper + this.XR) & 0x00FF],
        address: oper + this.XR
      };
    };

    CPU.prototype.zeropageY = function(oper) {
      return {
        operand: this.ram[(oper + this.YR) & 0x00FF],
        address: oper + this.YR
      };
    };

    CPU.prototype.addressing = function() {
      if (arguments.length === 2) {
        return arguments[1];
      } else {
        return this.immediate;
      }
    };

    CPU.stepInfo = {
      operand: 0x00,
      addressMode: CPU.immediate
    };

    CPU.prototype.step = function() {
      var operand;
      operand = this.ram[this.PC];
      return this.stepInfo.operand = operand;
    };

    CPU.prototype.accumulate = function(src, dst, carry) {
      return src + dst + carry;
    };

    CPU.prototype.setZ = function(oper) {
      return this.Z = oper === 0 ? 1 : 0;
    };

    CPU.prototype.setN = function(oper) {
      return this.N = (oper & 0x80) !== 0 ? 1 : 0;
    };

    CPU.prototype.setZN = function(oper) {
      this.setZ(oper);
      return this.setN(oper);
    };

    CPU.prototype.SED = function() {
      return this.D = 1;
    };

    CPU.prototype.SEC = function() {
      return this.C = 1;
    };

    CPU.prototype.CLC = function() {
      return this.C = 0;
    };

    CPU.prototype.CLD = function() {
      return this.D = 0;
    };

    CPU.prototype.LDA = function(oper) {
      return this.AC = this.addressing(arguments)(oper);
    };


    /*
    ADC  Add Memory to Accumulator with Carry
    
       A + M + C -> A, C                N Z C I D V
                                        + + + - - +
    
       addressing    assembler    opc  bytes  cyles
       --------------------------------------------
       immidiate     ADC #oper     69    2     2
       zeropage      ADC oper      65    2     3
       zeropage,X    ADC oper,X    75    2     4
       absolute      ADC oper      6D    3     4
       absolute,X    ADC oper,X    7D    3     4*
       absolute,Y    ADC oper,Y    79    3     4*
       (indirect,X)  ADC (oper,X)  61    2     6
       (indirect),Y  ADC (oper),Y  71    2     5*
     */

    CPU.prototype.ADC = function(stepInfo) {
      var H4b, operand;
      operand = stepInfo.operand;
      this.AC = this.accumulate(operand, this.AC, this.C);
      console.log('@AC', this.AC);
      this.C = this.AC > 0xFF ? 1 : 0;
      this.setZN(this.AC);
      H4b = this.AC / 0x10;
      this.V = H4b >= -8 & H4b <= 7 ? 0 : 1;
      if (this.V === 1) {
        console.warn('High 4 bit', H4b.toString(16), 'is not in rage(-8~7). Overflow!!');
      }
      console.log('@H4b is', H4b.toString(16));
      this.AC = this.AC & 0xFF;
      return this.printRegisters();
    };

    CPU.prototype.SBC = function(stepInfo) {
      var H4b, operand;
      operand = -stepInfo.operand;
      this.AC = this.accumulate(operand, this.AC, this.C);
      console.log('@AC', this.AC);
      this.C = this.AC > 0xFF ? 1 : 0;
      this.setZN(this.AC);
      H4b = this.AC / 0x10;
      this.V = H4b >= -8 & H4b <= 7 ? 0 : 1;
      if (this.V === 1) {
        console.warn('High 4 bit', H4b.toString(16), 'is not in rage(-8~7). Overflow!!');
      }
      console.log('@H4b is', H4b.toString(16));
      return this.AC = this.AC & 0xFF;
    };


    /*
    AND Memory with Accumulator
    
       A AND M -> A                     N Z C I D V
                                        + + - - - -
    
       addressing    assembler    opc  bytes  cyles
       --------------------------------------------
       immidiate     AND #oper     29    2     2
       zeropage      AND oper      25    2     3
       zeropage,X    AND oper,X    35    2     4
       absolute      AND oper      2D    3     4
       absolute,X    AND oper,X    3D    3     4*
       absolute,Y    AND oper,Y    39    3     4*
       (indirect,X)  AND (oper,X)  21    2     6
       (indirect),Y  AND (oper),Y  31    2     5*
     */

    CPU.prototype.AND = function(stepInfo) {
      var operand;
      operand = stepInfo.operand;
      this.AC = this.AC & operand & 0xFF;
      return this.setZN(this.AC);
    };


    /*
    ASL  Shift Left One Bit (Memory or Accumulator)
    
       C <- [76543210] <- 0             N Z C I D V
                                        + + + - - -
    
       addressing    assembler    opc  bytes  cyles
       --------------------------------------------
       accumulator   ASL A         0A    1     2
       zeropage      ASL oper      06    2     5
       zeropage,X    ASL oper,X    16    2     6
       absolute      ASL oper      0E    3     6
       absolute,X    ASL oper,X    1E    3     7
     */

    CPU.prototype.ASL = function(stepInfo) {
      var addressingMode, operand;
      operand = stepInfo.operand;
      addressingMode = stepInfo.address;
      this.C = (operand >> 7) & 1;
      operand <<= 1;
      console.log('1', addressingMode);
      if (addressingMode === this.ADDRESSING_MODE.ACCUMULATOR) {
        this.AC = operand;
      } else {
        this.ram[stepInfo.address];
      }
      return this.setZN(operand);
    };

    CPU.prototype.BCC = function(stepInfo) {
      if (this.C === 0) {
        return this.PC = stepInfo.address;
      }
    };

    CPU.prototype.BCS = function(stepInfo) {
      if (this === 1) {
        return this.PC = stepInfo.address;
      }
    };

    exports.CPU = CPU;

    return CPU;

  })();

}).call(this);
